package com.vine.math;

import java.util.logging.Level;
import java.util.logging.Logger;

public abstract class Matrixf {
    /**
     * Maximum difference two floating point values can differ and still count
     * as equal.
     */
    protected static final float EPSILON = 0.000000000000000000000001f;

    @FunctionalInterface
    protected static interface ElementOperation {
        /**
         * Operate on a element of a matrix with the given indices.
         */
        public void operate(int row, int column);
    }

    /**
     * Iterates the matrix and executes the operator method for each element one
     * time.
     */
    protected final void iterateMatrix(ElementOperation operator) {
        for (int i = 0; i < getSize(); i++) {
            for (int j = 0; j < getSize(); j++) {
                operator.operate(i, j);
            }
        }
    }

    protected Matrixf() {

    }

    protected abstract float getElement(int row, int column);

    protected abstract void setElement(int row, int column, float value);

    protected abstract int getSize();

    public abstract float determinant();

    public abstract void transpose();

    public abstract void inverse();

    /**
     * Makes this matrix the unit matrix.
     */
    public void makeIdentity() {
        iterateMatrix((row, column) -> setElement(row, column, row == column ? 1 : 0));
    }

    /**
     * Multiplies every element of the matrix with the given scale value.
     */
    public void uniformScale(float scale) {
        iterateMatrix((row, column) -> setElement(row, column, getElement(row, column) * scale));
    }

    private boolean isValidMatrix(Matrixf matrix) {
        return matrix == null || !this.getClass().equals(matrix.getClass());
    }

    /**
     * Multiplies the given matrix from the right with this Matrix3f.
     */
    public void multiply(Matrixf matrix) {
        if (isValidMatrix(matrix)) {
            Logger.getGlobal().log(Level.WARNING, "Tried to multiply matrix with null.");
            return;
        }
        final float[][] tempMatrix = new float[getSize()][getSize()];
        iterateMatrix((row, column) -> {
            for (int j = 0; j < getSize(); j++) {
                tempMatrix[row][column] += getElement(row, j) * matrix.getElement(j, column);
            }
        });
        iterateMatrix((row, column) -> setElement(row, column, tempMatrix[row][column]));
    }

    /**
     * Adds the entries of the given matrix to the elements of this matrix.
     */
    public void add(Matrixf matrix) {
        if (isValidMatrix(matrix)) {
            return;
        }
        iterateMatrix(
                (row, column) -> setElement(row, column, getElement(row, column) + matrix.getElement(row, column)));
    }

    /**
     * Returns true, if every element of this matrix is equal to the equivalent
     * element of the given matrix.
     */
    public boolean equalTo(Matrixf matrix) {
        if (isValidMatrix(matrix)) {
            Logger.getGlobal().log(Level.WARNING, "Tried to compare matrix with null.");
            return false;
        }
        for (int i = 0; i < getSize(); i++) {
            for (int j = 0; j < getSize(); j++) {
                if (Math.abs(matrix.getElement(i, j) - getElement(i, j)) > EPSILON) {
                    return false;
                }
            }
        }
        return true;
    }

    /**
     * Returns a string representation of this matrix.
     */
    @Override
    public final String toString() {
        String output = "";
        for (int i = 0; i < getSize(); i++) {
            for (int j = 0; j < getSize(); j++) {
                output += getElement(i, j) + ",";
            }
            output += "\n";
        }
        return output;
    }
}
