package com.vine.math;

import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * Represents a 3x3 Matrix, with floating point values as elements.
 * 
 * @author Steffen
 *
 */
public final class Matrix3f extends Matrixf {
    /**
     * Quadratic size of Matrix3f. 3...
     */
    protected static final int SIZE = 3;

    /**
     * Creates a new matrix identical to the given matrix.
     * 
     * @param matrix
     *            The matrix to copy.
     */
    public Matrix3f(final Matrix3f matrix) {
        iterateMatrix((row, column) -> setElement(row, column, matrix.getElement(row, column)));
    }

    /**
     * Creates a matrix filled with the given value.
     */
    public Matrix3f(final float value) {
        iterateMatrix((row, column) -> setElement(row, column, value));
    }

    @Override
    public int getSize() {
        return SIZE;
    }

    /**
     * Sets the elements of the row that responds to the given index.
     * 
     * @param rowIndex
     *            Valid values are in [0,2].
     */
    public final void setRow(final int rowIndex, final float e1, final float e2, final float e3) {
        if (rowIndex >= 0 && rowIndex < SIZE) {
            setElement(rowIndex, 0, e1);
            setElement(rowIndex, 1, e2);
            setElement(rowIndex, 2, e3);
        } else {
            Logger.getGlobal().log(Level.WARNING, "Tried to set row of Matrix3f with invalid index:" + rowIndex);
        }
    }

    /**
     * Calculates the determinant of this matrix and returns it.
     */
    private static final float determinant(final Matrix3f matrix) {
        return matrix.getElement(0, 0) * matrix.getElement(1, 1) * matrix.getElement(2, 2)
                + matrix.getElement(0, 1) * matrix.getElement(1, 2) * matrix.getElement(2, 0)
                + matrix.getElement(0, 2) * matrix.getElement(1, 0) * matrix.getElement(2, 1)
                - matrix.getElement(0, 1) * matrix.getElement(1, 0) * matrix.getElement(2, 2)
                - matrix.getElement(0, 2) * matrix.getElement(1, 1) * matrix.getElement(0, 2)
                - matrix.getElement(0, 0) * matrix.getElement(1, 2) * matrix.getElement(2, 1);
    }

    /**
     * Calculates the determinant of this matrix and returns it.
     */
    @Override
    public final float determinant() {
        return determinant(this);
    }

    /**
     * Transposes this matrix.
     */
    @Override
    public final void transpose() {
        float temp = getElement(1, 0);
        setElement(1, 0, getElement(0, 1));
        setElement(0, 1, temp);
        temp = getElement(2, 0);
        setElement(2, 0, getElement(0, 2));
        setElement(0, 2, temp);
        temp = getElement(2, 1);
        setElement(2, 1, getElement(1, 2));
        setElement(1, 2, temp);
    }

    /**
     * Transforms this matrix into its inversed matrix. Does nothin, if the
     * matrix is not invertable.
     */
    @Override
    public final void inverse() {
        final float[][] tempMatrix = new float[3][3];
        final float inversedDet = determinant();
        if (Math.abs(inversedDet) <= EPSILON) {
            return;
        }
        // Calculate elements of the inverse 3x3 matrix with the inversed
        // determinant defactored.
        tempMatrix[0][0] = elements[1][1] * elements[2][2] - elements[2][1] * elements[1][2];
        tempMatrix[0][1] = elements[2][1] * elements[0][2] - elements[2][2] * elements[0][1];
        tempMatrix[0][2] = elements[0][1] * elements[1][2] - elements[0][2] * elements[1][1];
        //
        tempMatrix[1][0] = elements[1][2] * elements[2][0] - elements[1][0] * elements[2][2];
        tempMatrix[1][1] = elements[0][0] * elements[2][2] - elements[0][2] * elements[2][0];
        tempMatrix[1][2] = elements[0][2] * elements[1][0] - elements[1][2] * elements[0][0];
        //
        tempMatrix[2][0] = elements[1][0] * elements[2][1] - elements[2][0] * elements[1][1];
        tempMatrix[2][1] = elements[0][1] * elements[2][0] - elements[0][0] * elements[2][1];
        tempMatrix[2][2] = elements[0][0] * elements[1][1] - elements[0][1] * elements[1][0];
        // assign calculated matrix elements to the corresponding elements of
        // this matrix.
        iterateMatrix((row, column) -> elements[row][column] = tempMatrix[row][column]);
        // Multiply with inversed determinant of this matrix
        uniformScale(1 / inversedDet);
    }
}
