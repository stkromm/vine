package vine.reflection;

import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.Optional;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * @author Steffen
 *
 * @param <T>
 *            The type of the managed class.
 */
public class VineClass<T> {

    /**
     * The class that is wrapped by this object.
     */
    Class<T> type;

    /**
     * @param type
     *            The class, that should be wrapped with a VineClass object.
     */
    public VineClass(Class<T> type) {
        this.type = type;
    }

    /**
     * @param methodName
     *            The name of the searched method
     * @return optional wrapper, that contains the method, if the class contains
     *         the a method with the given name.
     */
    public final Optional<Method> getMethodByName(String methodName) {
        return Arrays.stream(type.getMethods()).filter(method -> method.getName().equals(methodName)).findFirst();
    }

    /**
     * @return
     */
    public final T instantiateType() {
        T object = null;
        try {
            object = type.newInstance();
        } catch (InstantiationException e) {
            Logger.getGlobal()
                    .log(Level.SEVERE,
                            "Could not instantiate gameobject of class:" + type.getName()
                                    + "\nMaybe you passed a class, that is abstract and or does not inherit Gameobject",
                            e);
        } catch (IllegalAccessException e) {
            Logger.getGlobal().log(Level.SEVERE, "Could not instantiate gameobject of class:" + type.getName()
                    + "\n Perhaps you made the constructor private?\n", e);
        }
        return object;
    }

    /**
     * @param methodName
     *            The name of the method, that is looked for.
     * @param params
     *            The params, the method requires
     * @return true, if the class implements the given method with params of the
     *         given type and order.
     */
    public final boolean hasMethodImplemented(final String methodName, final java.lang.Class<?>... params) {
        Method method = null;
        try {
            method = type.getMethod(methodName, params);
        } catch (NoSuchMethodException | SecurityException e) {
            Logger.getGlobal().log(Level.SEVERE, "Auto-generated catch block", e);
        }
        return method != null && method.getDeclaringClass().equals(type);
    }
}
