package vine.application;

import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;

import vine.application.RenderLayer;
import vine.components.Camera;
import vine.components.Sprite;
import vine.entity.GameEntity;
import vine.game.Game;

/**
 * @author Steffen
 *
 */
public class Scene extends RenderLayer {
    /**
     * The game world.
     */
    Game world;
    /**
     * 
     */
    public final CameraManager cameras = new CameraManager();

    /**
     * Empty constructor.
     */
    Scene() {
        GameEntity entity = Game.instantiate(GameEntity.class);
        Sprite sprite = Game.instantiate(Sprite.class);
        entity.addComponent(sprite);
        entities.add(entity);
        entity.setScene(this);
        // package constructor so only SceneBuilder can create Scenes
    }

    @Override
    public void render() {
        entities.stream().forEach(renderer::submit);
        renderer.flush();
    }

    /**
     * @author Steffen
     *
     */
    public static class SceneBuilder {
        private SceneBuilder() {

        }

        /**
         * @param level
         *            The asset name of the level
         * @param world
         *            The world, that this scene exists in.
         * @return A newly created Scene.
         */
        public static Scene createScene(String level, Game world) {
            Logger.getGlobal().log(Level.INFO, level);
            Scene scene = new Scene();
            scene.world = world;
            return scene;
        }
    }

    /**
     * @author Steffen
     *
     */
    public class CameraManager {
        private List<Camera> managedCameras = new ArrayList<>();
        private Camera activeCamera = null;

        /**
         * 
         */
        CameraManager() {
            // Default Constructor visible, so only Scene can instantiate a
            // camera manager.
        }

        /**
         * @return The camera thats viewport is currently used to render.
         */
        public Camera getActiveCamera() {
            return activeCamera;
        }

        /**
         * @param camera
         *            Camera, that should be managed
         */
        public void removeCamera(Camera camera) {
            managedCameras.remove(camera);
        }

        /**
         * Use this method to create new cameras.
         * 
         * @return A camera that is usable in this Scene
         */
        public Camera instantiateCamera() {
            Camera camera = Game.instantiate(Camera.class);
            managedCameras.add(camera);
            return camera;
        }

        /**
         * @param camera
         *            The camera to activate
         */
        public void activate(Camera camera) {
            if (managedCameras.contains(camera)) {
                activeCamera = camera;
            }
        }
    }

    /**
     * @param delta
     *            The time that has passed since last update.
     */
    public void update(float delta) {
        entities.stream().forEach(e -> e.update(delta));
    }
}
