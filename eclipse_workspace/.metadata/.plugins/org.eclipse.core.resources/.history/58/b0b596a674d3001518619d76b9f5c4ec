package vine.tilemap;

import vine.game.Game;
import vine.graphics.VertexBufferObject;

public class TileMapRenderData {

    private final VertexBufferObject vertexBuffer;
    private final TileMap tileMap;

    private int screenxTiles = 42;
    private int screenyTiles = 27;

    private final float[] vertices;
    private final float[] uvs;

    private int cachedCameraX;
    private int cachedCameraY;

    private final GridCalculator verticeGridCalc = new GridCalculator();
    private final float[] squadVertices = new float[12];

    public TileMapRenderData(final TileMap map) {
        tileMap = map;
        screenxTiles = Game.getGame().getScreen().getWidth() / 32 + 2;
        screenyTiles = Game.getGame().getScreen().getHeight() / 32 + 2;
        //
        final int[] indices = new int[6 * screenxTiles * screenyTiles];
        this.vertices = new float[12 * screenxTiles * screenyTiles];
        this.uvs = new float[8 * screenxTiles * screenyTiles];
        final int startX = 0;
        final int startY = 0;
        for (int i = startX; i < startX + screenxTiles; i++) {
            for (int j = startY; j < startY + screenyTiles; j++) {
                final int index = getGridArrayIndex(i - startX, j - startY, screenxTiles);
                System.arraycopy(
                        new int[] { index * 4, index * 4 + 1, index * 4 + 2, index * 4 + 2, index * 4 + 3, index * 4 },
                        0, indices, index * 6, 6);
            }
        }
        vertexBuffer = new VertexBufferObject(vertices, indices, uvs, Game.getGame().getGraphics());
    }

    private static final int getGridArrayIndex(int x, int y, int width) {
        return x + y * width;
    }

    /**
     * @return
     */
    public final VertexBufferObject getRenderData(int x, int y) {
        final int cameraX = x / 32 - screenxTiles / 2 + 1;
        final int cameraY = y / 32 - screenyTiles / 2 + 1;

        if (cameraY != cachedCameraY || cameraX != cachedCameraX) {
            verticeGridCalc.calculateVertexGrid(cameraX, cameraY, screenxTiles, screenyTiles, vertices);
            vertexBuffer.changeVertices(vertices);
        }
        cachedCameraX = cameraX;
        cachedCameraY = cameraY;
        for (int i = uvs.length - 1; i >= 0; i--) {
            uvs[i] = 0;
        }
        for (int i = cameraX + screenxTiles - 1; i >= cameraX; i--) {
            for (int j = cameraY + screenyTiles - 1; j >= cameraY; j--) {
                final int index = (i - cameraX) + (j - cameraY) * screenxTiles;
                int tile = i + j * tileMap.getWidth();
                if (tile > 0 && tile < tileMap.getHeight() * tileMap.getWidth()) {
                    System.arraycopy(tileMap.tiles[tile].getUVCoordinates(), 0, uvs, index * 8, 8);
                }
            }
        }
        vertexBuffer.changeTexture(uvs);
        return vertexBuffer;
    }
}
