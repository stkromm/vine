package main

import org.lwjgl._
import org.lwjgl.glfw._
import org.lwjgl.opengl._
import org.lwjgl.glfw.GLFW._
import org.lwjgl.opengl.GL11._
import org.lwjgl.system.MemoryUtil._
import java.util.Calendar
import java.util.concurrent.TimeUnit

import scala.util.Try
import scala.math

class Screen {

  // We need to strongly reference callback instances.
  private var errorCallback = None: Option[GLFWErrorCallback]
  private var keyCallback = None: Option[GLFWKeyCallback]
  private var lastFrameDuration = 0.0

  val vsync = 2
  val maxFrameDuration = 8
  val WIDTH = 300;
  val HEIGHT = 300;
  val title = "Hello World!"

  def loop(previous: Long) {
    pollInput()
    update()
    render()
    // Only needed, when vsync disabled
    if (vsync != 0 && maxFrameDuration != 0) {
      val frameDuration = math.max(0L, maxFrameDuration * 1000000L - java.lang.System.nanoTime + previous)
      if (frameDuration >= 500) {
        TimeUnit.NANOSECONDS.sleep(frameDuration);
      }
    }
    lastFrameDuration = 1000000000 / (java.lang.System.nanoTime - previous);
    println(lastFrameDuration)
    if (glfwWindowShouldClose(glfwGetCurrentContext) == GLFW_FALSE) {
      loop(java.lang.System.nanoTime)
    }
  }
  def run() {

    try {
      init();
      GL.createCapabilities();
      glClearColor(1.0f, 0.0f, 0.0f, 0.0f);
      loop(java.lang.System.nanoTime);
      // Release window and window callbacks
      glfwDestroyWindow(glfwGetCurrentContext);
    } finally {
      Try(keyCallback.get.release());
      // Terminate GLFW and release the GLFWErrorCallback
      glfwTerminate();
      Try(errorCallback.get.release());
    }
  }

  def init() {
    // Setup an error callback. The default implementation
    // will print the error message in System.err.
    errorCallback = Option(glfwSetErrorCallback(GLFWErrorCallback.createPrint(System.err)))

    // Initialize GLFW. Most GLFW functions will not work before doing this.
    if (glfwInit() != GLFW_TRUE)
      throw new IllegalStateException("Unable to initialize GLFW");

    // Configure our window
    glfwDefaultWindowHints(); // optional, the current window hints are already the default
    glfwWindowHint(GLFW_VISIBLE, GLFW_FALSE); // the window will stay hidden after creation
    glfwWindowHint(GLFW_RESIZABLE, GLFW_TRUE); // the window will be resizable

    // Create the window
    val window = glfwCreateWindow(WIDTH, HEIGHT, title, NULL, NULL);
    if (window == NULL)
      throw new RuntimeException("Failed to create the GLFW window");

    // Get the resolution of the primary monitor
    val vidmode = glfwGetVideoMode(glfwGetPrimaryMonitor());
    // Center our window
    glfwSetWindowPos(
      window,
      (vidmode.width() - WIDTH) / 2,
      (vidmode.height() - HEIGHT) / 2);

    // Make the OpenGL context current
    glfwMakeContextCurrent(window);
    // Enable v-sync
    glfwSwapInterval(vsync);
    // Make the window visible
    glfwShowWindow(window);
  }
  def update() {

  }
  def render() {
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // clear the framebuffer
    glfwSwapBuffers(glfwGetCurrentContext); // swap the color buffers

  }
  def pollInput() {
    glfwPollEvents();
  }
}
